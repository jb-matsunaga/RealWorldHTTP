# 4.HTTP/1.1のシンタックス：高速化と安全性を求めた拡張

本章で取り上げる、プロトコルシンタックスとしてのHTTP/1.1の変更点は次の通り。
 - 通信の高速化
    - Keep-Aliveがデフォルトで有効に
    - パイプライニング
- TLSによる暗号化通信のサポート
- 新メソッドの追加
    - PUTとDELETEが必須のメソッドとなった
    - OPTION, TRACE, CONNECT メソッドが追加
- プロトコルのアップグレード
- 名前を使ったバーチャルホストのサポート
- サイズが事前にわからないコンテンツのチャンク転送エンコーディングのサポート

## 4.1 通信の高速化
キャッシュはコンテンツのリソースごとに通信を最適化する技術だが、Keep-Aliveと、パイプライニングはより汎用的な、すべてのHTTP通信を高速化する機能である。

### 4.1.1 Keep-Alive
Keep-Aliveは、HTTPの下のレイヤーであるTCP/IPの通信を効率化する仕組み。

Keep-Aliveを使わない場合は、ひとつのリクエストごとに通信を閉じるが、Keep-Aliveを使うと連続したリクエストの時に接続を再利用する。TCP/IPは接続までの待ち時間が減り、通信速度が上がったように感じる。

![](./img/keep-alive.png)

(1回のTCP接続で複数のHTTPリクエストを処理する機能)

Keep-Aliveによる通信は、クライアント、サーバーのどちらかが次のヘッダーを付与して接続を切るか、タイムアウトするまで接続が維持される。

```
Connection: Close
```

Keep-Aliveの接続時間は、クライアントとサーバーの両方が持っている。片方がTCP/IPの切断を行った瞬間に通信が完了するため、どちらか短い方が採用される。



>*参照*
- [持続接続](https://docs.oracle.com/javase/jp/6/technotes/guides/net/http-keepalive.html)
- [TCP/IP通信とは](http://research.nii.ac.jp/~ichiro/syspro98/tcpip.html)
- [Nginx の keep-alive の設定と検証](http://www.nari64.com/?p=579)


### 4.1.2 パイプライニング
パイプライニングは最初のリクエストが完了する前に次のリクエストを送信し、「レスポンスを待って次のリクエストを出す」までの待ち時間を排除することでネットワークの稼働率をあげ、パフォーマンスを向上させる機能。

Keep-Aliveの利用を前提としている。また、仕様上、サーバーはリクエストが来た順序でレスポンスを返すことになっている。

![pipeline](./img/pipeline.png)

レスポンスの生成に時間がかかる処理やファイルサイズの大きいファイルを返す処理があると、他のレスポンスを阻害する。これはHead-of-Blocking(HOL Blocking)と呼ばれる問題。

パイプライニングのパフォーマンスが活かしきれなかった問題があった。

*後のHTTP/2においてストリームという新しい仕組みとして生まれ変わった*

## 4.2 TLS(トランスポート・レイヤー・セキュリティ)

HTTP/1.1と並行して通信経路を暗号化するTLSが規格化された。

TLSはHTTP/1.1と共同利用されることを強く意識して作られたが、TLSの暗号化自体はHTTPに依存せず、さまざまな形式のデータを双方向に流すことができる。TLSは、既存のプロトコルに通信経路の安全性をプラスした新たなプロトコルを作り出すことのできる汎用的な仕組みになっている。

| プロトコル | ポート |
|:-----------|------------:|
| HTTP       | 80        |
| HTTPS(HTTP Secure)     | 443      |
| SMTP       | 25        |
| SMTPS         | 465          |

既存のプロトコルのバージョンアップに利用されている。

HTTPの通信を途中で中継するゲートウェイから見ると「暗号化されていて通信の内容をのぞいたり変更ができない双方向通信」。

TLSはいくつかバージョンがありSSLと呼ばれていた頃もあった。現在のSSLは、さまざまな虚弱性が知られており、RFC上でも非推奨とされている。実際に使われているのはほとんどがTLSである。

### 4.2.1 ハッシュ関数

入力データから、ルールに従ってデータを集約していくことで、ハッシュ値と呼ばれる短いデータを作り出す。

ハッシュ関数には暗号化通信を行う上で便利な数学的特性がある。
ハッシュ関数をh(), 入力データをA, B...., 算出されたハッシュ値を X, Y... とする。長さは len() とする。

- 同じアルゴリズムと同じ入力データであれば、結果として作られるハッシュ値は同じになる。
    - h(A) = X が常になりたつ
- ハッシュ値はアルゴリズムが同じであれば、同じ長さとなる。
- ハッシュ値から元のデータを類即することは難しい（弱衝突体制）
- 同一ハッシュ値を持つ任意のデータの組みを見つけるのが難しい（強衝突体制）

ハッシュ関数はコンピュータの中で様々な用途につかわれている。
例えば、バージョン管理システムのGitでは、ファイルを管理するときにファイル名ではなくファイルの内容をもとにしたハッシュ値を用いており、このハッシュ値をキーにしてファイルをデータベースに格納している。
同じ内容のファイルが複数あった場合、データの実態は一つで済む。
また長大なデータファイル全てを比較せずハッシュ値だけを比較することで、すばやく「ファイルの内容がことなる」ことを判定できる。

セキュリティ用途でも、ハッシュ値は内容の同一性を判断する用途で使われる。

```
$ openssl sha1 keep-alive.png
SHA1(keep-alive.png)= 3b722faa3669ffde26795abafece1b4bb881f581
```