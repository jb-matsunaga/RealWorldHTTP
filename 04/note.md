# 4.HTTP/1.1のシンタックス：高速化と安全性を求めた拡張

本章で取り上げる、プロトコルシンタックスとしてのHTTP/1.1の変更点は次の通り。
 - 通信の高速化
    - Keep-Aliveがデフォルトで有効に
    - パイプライニング
- TLSによる暗号化通信のサポート
- 新メソッドの追加
    - PUTとDELETEが必須のメソッドとなった
    - OPTION, TRACE, CONNECT メソッドが追加
- プロトコルのアップグレード
- 名前を使ったバーチャルホストのサポート
- サイズが事前にわからないコンテンツのチャンク転送エンコーディングのサポート

## 4.1 通信の高速化
キャッシュはコンテンツのリソースごとに通信を最適化する技術だが、Keep-Aliveと、パイプライニングはより汎用的な、すべてのHTTP通信を高速化する機能である。

### 4.1.1 Keep-Alive
Keep-Aliveは、HTTPの下のレイヤーであるTCP/IPの通信を効率化する仕組み。

Keep-Aliveを使わない場合は、ひとつのリクエストごとに通信を閉じるが、Keep-Aliveを使うと連続したリクエストの時に接続を再利用する。TCP/IPは接続までの待ち時間が減り、通信速度が上がったように感じる。

![](./img/keep-alive.png)

(1回のTCP接続で複数のHTTPリクエストを処理する機能)

Keep-Aliveによる通信は、クライアント、サーバーのどちらかが次のヘッダーを付与して接続を切るか、タイムアウトするまで接続が維持される。

```
Connection: Close
```

Keep-Aliveの接続時間は、クライアントとサーバーの両方が持っている。片方がTCP/IPの切断を行った瞬間に通信が完了するため、どちらか短い方が採用される。



>*参照*
- [持続接続](https://docs.oracle.com/javase/jp/6/technotes/guides/net/http-keepalive.html)
- [TCP/IP通信とは](http://research.nii.ac.jp/~ichiro/syspro98/tcpip.html)
- [Nginx の keep-alive の設定と検証](http://www.nari64.com/?p=579)


### 4.1.2 パイプライニング
パイプライニングは最初のリクエストが完了する前に次のリクエストを送信し、「レスポンスを待って次のリクエストを出す」までの待ち時間を排除することでネットワークの稼働率をあげ、パフォーマンスを向上させる機能。

Keep-Aliveの利用を前提としている。また、仕様上、サーバーはリクエストが来た順序でレスポンスを返すことになっている。

![pipeline](./img/pipeline.png)

レスポンスの生成に時間がかかる処理やファイルサイズの大きいファイルを返す処理があると、他のレスポンスを阻害する。これはHead-of-Blocking(HOL Blocking)と呼ばれる問題。

パイプライニングのパフォーマンスが活かしきれなかった問題があった。

*後のHTTP/2においてストリームという新しい仕組みとして生まれ変わった*

## 4.2 TLS(トランスポート・レイヤー・セキュリティ)

HTTP/1.1と並行して通信経路を暗号化するTLSが規格化された。

TLSはHTTP/1.1と共同利用されることを強く意識して作られたが、TLSの暗号化自体はHTTPに依存せず、さまざまな形式のデータを双方向に流すことができる。TLSは、既存のプロトコルに通信経路の安全性をプラスした新たなプロトコルを作り出すことのできる汎用的な仕組みになっている。

| プロトコル | ポート |
|:-----------|------------:|
| HTTP       | 80        |
| HTTPS(HTTP Secure)     | 443      |
| SMTP       | 25        |
| SMTPS         | 465          |

既存のプロトコルのバージョンアップに利用されている。

HTTPの通信を途中で中継するゲートウェイから見ると「暗号化されていて通信の内容をのぞいたり変更ができない双方向通信」。

TLSはいくつかバージョンがありSSLと呼ばれていた頃もあった。現在のSSLは、さまざまな虚弱性が知られており、RFC上でも非推奨とされている。実際に使われているのはほとんどがTLSである。

### 4.2.1 ハッシュ関数

入力データから、ルールに従ってデータを集約していくことで、ハッシュ値と呼ばれる短いデータを作り出す。

ハッシュ関数には暗号化通信を行う上で便利な数学的特性がある。
ハッシュ関数をh(), 入力データをA, B...., 算出されたハッシュ値を X, Y... とする。長さは len() とする。

- 同じアルゴリズムと同じ入力データであれば、結果として作られるハッシュ値は同じになる。
    - h(A) = X が常になりたつ
- ハッシュ値はアルゴリズムが同じであれば、同じ長さとなる。
- ハッシュ値から元のデータを類即することは難しい（弱衝突体制）
- 同一ハッシュ値を持つ任意のデータの組みを見つけるのが難しい（強衝突体制）

ハッシュ関数はコンピュータの中で様々な用途につかわれている。
例えば、バージョン管理システムのGitでは、ファイルを管理するときにファイル名ではなくファイルの内容をもとにしたハッシュ値を用いており、このハッシュ値をキーにしてファイルをデータベースに格納している。
同じ内容のファイルが複数あった場合、データの実態は一つで済む。
また長大なデータファイル全てを比較せずハッシュ値だけを比較することで、すばやく「ファイルの内容がことなる」ことを判定できる。

セキュリティ用途でも、ハッシュ値は内容の同一性を判断する用途で使われる。

```
$ openssl sha1 keep-alive.png
SHA1(keep-alive.png)= 3b722faa3669ffde26795abafece1b4bb881f581
```

### 4.2.2 共通鍵暗号と公開鍵暗号とデジタル署名

暗号のアルゴリズムで大事だとされていることは、アルゴリズムそのものを秘密にするのではなく、アルゴリズムが公開されていても安全に通信できることである。

現在一般的に使われるのは、暗号化方式はオープンだが、その暗号化に使うデータ（鍵）を別に用意する方式である。TLSで使われているものには、共通鍵方式と、公開鍵方式の2種類がある。

#### 共通鍵方式
- 対象暗号とも呼ばれる。
- 鍵をかけるのと鍵をあけるのに同じ鍵を使う方式。

「鍵のデータに従ってデータを壊す」

鍵があれば壊れたデータから正しく修理することができるので、受け取り手はデータを復元して読める。TLSでは、通常の通信の暗号化に使う。

#### 公開鍵方式
- 非対称暗号とも呼ばれる。
- 必要なものは公開鍵と秘密鍵。

暗号化する鍵と、それを復元かする鍵が別になっている。暗号化する方が公開鍵で、復号化する方が秘密鍵である。

例えると、公開鍵は南京錠、秘密鍵はその鍵である。

#### デジタル署名
- 公開鍵方式の応用例
- 逆に鍵の方をくばって、南京錠を秘密にしておくようなイメージ

### 4.2.3 鍵交換
鍵交換は、クライアントとサーバー間で鍵を交換する。

#### DH(ディフィー・ヘルマン)鍵交換アルゴリズム
鍵そのものを交換せず、クライアントとサーバーでそれぞれ鍵の材料を作り、お互いに交換しあって、それぞれの場所で計算して同じ鍵を得る。

[Diffie-hellman key exchange
](https://www.khanacademy.org/computing/computer-science/cryptography/modern-crypt/v/diffie-hellman-key-exchange-part-2)

### 4.2.4 共通鍵方式と公開鍵方式を使い分ける理由
TLSは、両方の方式を組み合わせている。通信毎に一度だけ使われる共通鍵を作り、公開鍵方式を使って通信相手へ厳重に鍵を受け渡し、その後は共通鍵で高速に暗愚かを行うという2段階の方式を利用している。

公開鍵方式の方が安全性は高いのだが、鍵を持っている多としても暗号化と復号化に必要な計算量が共通鍵方式に比べて大きすぎるためである。

実際に使用されている共通鍵（AES）と、公開鍵方式（RSA）のパフォーマンスを測定してみる。

[benchmark_common_and_public_key_test.go](https://github.com/jb-matsunaga/RealWorldHTTP/blob/master/04/benchmark_common_and_public_key_test.go)


▽ベンチマークの結果
| 暗号方式 | モード | 時間(ナノ秒)| スルーピット|
|:--------|----------|----------|------------:|
| RSA     | 暗号化    |84338  |1.5MB/秒|
| RSA     | 復号化    |2874037| 45KB/秒|
| AES     | 暗号化    |184    |690MB/秒|
| AES     | 復号化    |184    |690MB/秒|

RSA(公開鍵)よりAES(共通鍵)の方が断然速い

### 4.2.5 TLSの通信手順

TLSの通信は大きく3つに分けることができる。
- ハンドシェイクプロトコル通信を確立するステップ
- レコードプロトコル通信時のステップ
- SessionTicketという仕組みを使った、再接続時の高速なハンドシェイク

#### 4.2.5.1 サーバーの信頼性を確認
サーバーの信頼性を保証する仕組みは、公開鍵の保証する仕組みでもあり、公開鍵基盤(Public Key Infrastructure)と呼ばれる。

1. SSLサーバー証明書を取得
2. サーバー証明書の信頼性を確認
3. 共通鍵を作成し、証明書内の公開鍵で暗号化
4. 暗号化された鍵の復号
5. 復号した鍵で通信









